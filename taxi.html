<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>íƒì‹œ ë§ˆìŠ¤í„°</title>
    <!-- Tone.js ë¼ì´ë¸ŒëŸ¬ë¦¬ ì¶”ê°€ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap');

        :root {
            --grid-size: 10;
            --cell-size: 40px;
            --border-color: #ddd;
            --text-color: #333;
            --background-color: #f9f9f9;
            --panel-background: #ffffff;
            --button-primary-color: #007BFF;
            --button-primary-hover: #0069D9;
            --board-background: #ecf0f1;
            --path-color: #a7f3d0;
        }
        
        body.dark-mode {
            --border-color: #444;
            --text-color: #eee;
            --background-color: #1a1a1a;
            --panel-background: #2c3e50;
            --board-background: #34495e;
            --path-color: #2a4b3d;
        }

        body {
            font-family: 'Noto Sans KR', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: var(--background-color);
            margin: 0;
            color: var(--text-color);
            flex-direction: column;
            padding: 20px;
            box-sizing: border-box;
            transition: background-color 0.3s, color 0.3s;
        }

        h1 {
            color: var(--text-color);
            margin-bottom: 20px;
            font-weight: 700;
        }

        #game-container, #hidden-stage-container {
            display: none;
            flex-direction: row; 
            background-color: var(--panel-background);
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            margin-bottom: 20px;
            width: 100%;
            transition: background-color 0.3s;
        }
        #game-container { max-width: 800px; } 
        #hidden-stage-container { max-width: 900px; align-items: stretch; }

        #game-board, #hidden-stage-board {
            display: grid;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            overflow: hidden;
            margin: 20px;
            flex-shrink: 0;
            background-color: var(--board-background);
            transition: background-color 0.3s, border-color 0.3s;
        }
        #game-board {
            grid-template-columns: repeat(var(--grid-size), var(--cell-size));
            grid-template-rows: repeat(var(--grid-size), var(--cell-size));
        }
         #hidden-stage-board {
            --hidden-grid-size: 16;
            --hidden-cell-size: 30px;
            grid-template-columns: repeat(var(--hidden-grid-size), var(--hidden-cell-size));
            grid-template-rows: repeat(var(--hidden-grid-size), var(--hidden-cell-size));
        }

        .cell, .hidden-cell {
            box-sizing: border-box;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #fff;
            font-size: 1.5rem; 
        }
        
        body.dark-mode .cell, body.dark-mode .hidden-cell { background-color: #4a637d; }
        body.dark-mode .hidden-cell.wall { background-color: #2c3e50; }

        .cell {
            width: var(--cell-size); height: var(--cell-size);
            border: 1px solid var(--border-color);
            transition: background-color 0.3s, border-color 0.3s;
        }
        .cell.path {
            background-color: var(--path-color);
        }

         .hidden-cell { 
            width: var(--hidden-cell-size); 
            height: var(--hidden-cell-size); 
            font-size: 1.2em;
        }
        .hidden-cell.wall { background-color: #34495e; }

        #sidebar, #hidden-sidebar {
            flex-grow: 1; padding: 20px; background-color: #f0f0f0;
            display: flex; flex-direction: column; justify-content: space-between;
            border-left: 1px solid var(--border-color);
            transition: background-color 0.3s, border-color 0.3s;
        }
        
        body.dark-mode #sidebar, body.dark-mode #hidden-sidebar { background-color: #2c3e50; border-left: 1px solid #444; }
        
        #hidden-sidebar { width: 250px; flex-grow: 0; }

        #hud p, #hidden-hud p { margin: 10px 0; font-size: 1.1em; font-weight: 700; }
        #hud span, #hidden-hud span { font-weight: 400; margin-left: 8px; color: #555; }
        body.dark-mode #hud span, body.dark-mode #hidden-hud span { color: #ccc; }
        #message, #hidden-message { 
            margin-top: 20px; font-weight: 700; color: #E74C3C; 
            text-align: center; min-height: 20px; 
        }
        
        button {
            background-color: var(--button-primary-color); color: white; padding: 12px 18px; border: none; border-radius: 8px;
            cursor: pointer; font-size: 1.1em; font-weight: 700; margin-top: 15px;
            transition: background-color 0.3s ease, transform 0.2s ease;
        }
        button:hover { background-color: var(--button-primary-hover); transform: translateY(-2px); }
        button:disabled { background-color: #aaa; cursor: not-allowed; transform: none; }
        
        .modal {
            display: none; position: fixed; left: 0; top: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.6); justify-content: center; align-items: center; z-index: 1000;
        }
        .modal-content {
            background-color: var(--panel-background); color: var(--text-color); padding: 30px 40px; border-radius: 12px;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.2); text-align: center; max-width: 500px; width: 90%; max-height: 80vh; overflow-y: auto;
            transition: background-color 0.3s, color 0.3s;
        }
        .modal-content h2 { margin-top: 0; font-weight: 700; }
        .modal-content p { margin: 15px 0; font-size: 1.1em; line-height: 1.6; }
        .modal-content ul { list-style: none; padding: 0; margin: 20px 0; text-align: left; }
        .modal-content ul li { margin-bottom: 10px; font-size: 1.1em; display: flex; align-items: center; }
        .modal-content ul li span { 
            width: 24px; height: 24px; margin-right: 10px; 
            font-size: 24px; display: inline-block; text-align: center;
        }
        
        /* ë¡œë¹„ ë²„íŠ¼ */
        #lobby-modal .difficulty-buttons { 
            display: grid; 
            grid-template-columns: 1fr; /* Simplified to 1 column */ 
            gap: 15px; 
            margin-top: 25px; 
        }
        #lobby-modal .difficulty-buttons button { width: 100%; margin-top: 0; }
        #btn-play { background-color: #28a745; }
        #btn-play:hover { background-color: #218838; }
        #btn-practice { background-color: #17a2b8; }
        #btn-practice:hover { background-color: #138496; }
        #btn-hidden-stage { background-color: #6f42c1; } 
        #btn-hidden-stage:hover { background-color: #5a32a3; }
        #btn-tutorial { background-color: #6c757d; } 
        #btn-tutorial:hover { background-color: #5a6268; }
        
        /* ë‚œì´ë„ ì„ íƒ ëª¨ë‹¬ ë²„íŠ¼ */
        #difficulty-modal .difficulty-buttons { display: flex; flex-direction: column; gap: 15px; margin-top: 25px; }
        #difficulty-modal button { width: 100%; margin-top: 0; }
        #btn-easy { background-color: #28a745; } #btn-easy:hover { background-color: #218838; }
        #btn-normal { background-color: #ffc107; color: #333 } #btn-normal:hover { background-color: #e0a800; }
        #btn-hard { background-color: #dc3545; } #btn-hard:hover { background-color: #c82333; }

        #grade-details {
            margin-top: 20px;
            font-size: 0.9em;
            color: #666;
            text-align: left;
            background-color: var(--board-background); 
            padding: 10px;
            border-radius: 8px;
        }
        body.dark-mode #grade-details { color: #ccc; }
        
        /* ì„¤ì • (ë‹¨ìˆœí™”) */
        #settings-controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            align-items: center;
            margin-top: 20px;
        }
        #settings-controls button {
            margin-top: 0;
            padding: 8px 12px;
            font-size: 0.9em;
            background-color: #6c757d;
        }
        #settings-controls button:hover {
            background-color: #5a6268;
        }

        /* ëª¨ë°”ì¼ ì»¨íŠ¸ë¡¤ëŸ¬ */
        #mobile-controls { display: none; position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); width: 180px; height: 120px; grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(2, 1fr); gap: 5px; z-index: 100; }
        #mobile-controls button { font-size: 1.8em; margin: 0; padding: 0; opacity: 0.7; background-color: #555; border-radius: 50%; user-select: none; }
        #mobile-controls button:active { transform: scale(0.95); }
        #btn-mobile-up { grid-column: 2; grid-row: 1; } #btn-mobile-left { grid-column: 1; grid-row: 2; } #btn-mobile-right { grid-column: 3; grid-row: 2; } #btn-mobile-down { grid-column: 2; grid-row: 2; }
        
        /* ë°˜ì‘í˜• ìŠ¤íƒ€ì¼ */
        @media (max-width: 768px) { 
            #game-container, #hidden-stage-container { 
                flex-direction: column; 
                height: auto; 
                margin-top: 20px; 
                margin-bottom: 150px; 
            } 
            #sidebar, #hidden-sidebar { 
                width: 100%; 
                border-left: none; 
                border-top: 1px solid var(--border-color); 
            } 
            body.dark-mode #sidebar, body.dark-mode #hidden-sidebar { 
                border-top: 1px solid #444; 
            } 
            #game-container { max-width: 100%; } 
        }
        @media (max-width: 500px) { 
            body { padding: 10px; } 
            h1 { font-size: 1.5em; } 
            :root { --cell-size: 35px; } 
            #hidden-stage-board { --hidden-cell-size: 20px; } 
            #game-board, #hidden-stage-board { margin: 10px; } 
        }
    </style>
</head>
<body>

    <div id="main-title" style="text-align: center;"> <h1>ğŸš• íƒì‹œ ë§ˆìŠ¤í„° ğŸš•</h1> </div>
    <div id="game-container"> <div id="game-board"></div> <div id="sidebar"> <div> <p><strong>ë‚œì´ë„: <span id="difficulty-display"></span></strong></p> <div id="hud"> <p>ì—°ë£Œ: <span id="fuel-display">0</span></p> <p>ìŠ¹ê°: <span id="passenger-display">0</span></p> <p>ì´ë™: <span id="moves-display">0</span></p> </div> </div> <div> <p id="message"></p> <button id="main-menu-button">ë©”ì¸ ë©”ë‰´ë¡œ</button> </div> </div> </div>
    <div id="hidden-stage-container"> <div id="hidden-stage-board"></div> <div id="hidden-sidebar"> <h2>ì¶”ê²©ì „!</h2> <p>ì¶”ê²©ìë¥¼ í”¼í•´ ì¶œêµ¬(ğŸ)ê¹Œì§€ ë„ë§ì¹˜ì„¸ìš”!</p> <div id="hidden-hud"> <p>ë‚¨ì€ ì‹œê°„: <span id="time-display">60</span>ì´ˆ</p> </div> <p id="hidden-message"></p> <button id="hidden-main-menu-button">í¬ê¸°í•˜ê¸°</button> </div> </div>
    
    <!-- Modals -->
    <div id="lobby-modal" class="modal" style="display: flex;"> <div class="modal-content"> <h2>ë©”ì¸ ë©”ë‰´</h2> <p>í™˜ì˜í•©ë‹ˆë‹¤!</p> <div class="difficulty-buttons">
            <button id="btn-play">ğŸ® ê²Œì„ ì‹œì‘</button>
            <button id="btn-practice">ğŸ¯ ì—°ìŠµ ëª¨ë“œ</button>
            <button id="btn-tutorial">ğŸ“– ê²Œì„ ë°©ë²•</button> 
            <button id="btn-hidden-stage" style="display:none;"> <strong>âœ¨ íˆë“  ìŠ¤í…Œì´ì§€ âœ¨</strong> </button> 
        </div> 
        <div id="settings-controls">
            <button id="toggle-dark-mode">í…Œë§ˆ: ë¼ì´íŠ¸</button>
            <button id="toggle-music">ìŒì•…: ì¼œê¸°</button>
        </div>
    </div> </div>
            
    <div id="difficulty-modal" class="modal">
        <div class="modal-content">
            <h2 id="difficulty-modal-title">ë‚œì´ë„ ì„ íƒ</h2>
            <p>í”Œë ˆì´í•  ë‚œì´ë„ë¥¼ ì„ íƒí•˜ì„¸ìš”.</p>
            <div class="difficulty-buttons">
                <button id="btn-easy">ì´ì§€ (Easy)</button>
                <button id="btn-normal">ë…¸ë§ (Normal)</button>
                <button id="btn-hard">í•˜ë“œ (Hard)</button>
                <button id="btn-difficulty-back" style="background-color: #6c757d;">ë’¤ë¡œê°€ê¸°</button>
            </div>
        </div>
    </div>

    <div id="tutorial-modal" class="modal"> <div class="modal-content"> 
        <h2>ê²Œì„ ì„¤ëª…</h2> 
        <ul> 
            <li><span>ğŸš–</span><strong>íƒì‹œ</strong>: ë‹¹ì‹ ì˜ ì°¨ëŸ‰</li> 
            <li><span>ğŸ§</span><strong>ìŠ¹ê°</strong>: íƒœì›Œì•¼ í•  ëª©í‘œ</li> 
            <li><span>â›½</span><strong>ì—°ë£Œí†µ</strong>: íšë“ ì‹œ ì—°ë£Œ +5</li> 
            <li><span>ğŸ¢</span><strong>ê±´ë¬¼</strong>: í†µê³¼ ë¶ˆê°€ëŠ¥í•œ ì¥ì• ë¬¼</li> 
            <li><span>ğŸ‘¤</span><strong>ë³´í–‰ì</strong>: ì¶©ëŒ ì‹œ ì—°ë£Œ -1 (ë…¸ë§/í•˜ë“œ)</li> 
            <li><span style="background-color: var(--path-color); border: 1px solid #999; border-radius: 4px; padding: 0 4px;">&nbsp;</span><strong>ê²½ë¡œ</strong>: ì—°ìŠµ ëª¨ë“œì—ì„œë§Œ í‘œì‹œ</li> 
        </ul> 
        <p>ë°©í–¥í‚¤(â†‘ â†“ â† â†’) ë˜ëŠ” WASDë¡œ ìŠ¹ê°ì„ íƒœìš°ì„¸ìš”. ì—°ë£Œê°€ 0ì´ ë˜ë©´ ê²Œì„ ì˜¤ë²„!</p>
        <div id="grade-details-tutorial" style="background-color: var(--board-background); margin-top: 20px; font-size: 0.9em; color: #666; text-align: left; padding: 10px; border-radius: 8px;">
            <!-- ì›ë³¸ ì½”ë“œì˜ 'grade-details' IDê°€ ì¤‘ë³µë˜ì–´ 'grade-details-tutorial'ë¡œ ë³€ê²½ -->
            <strong>â­ ë³„ì  ê¸°ì¤€ (ì—°ìŠµ ëª¨ë“œ ì œì™¸)</strong><br>
            â˜…â˜†â˜†â˜†â˜†: ìŠ¹ê° 1ëª… ì´ìƒ<br>
            â˜…â˜…â˜†â˜†â˜†: ìŠ¹ê° 3ëª… ì´ìƒ<br>
            â˜…â˜…â˜…â˜†â˜†: ìŠ¹ê° 6ëª… ì´ìƒ<br>
            â˜…â˜…â˜…â˜…â˜†: ìŠ¹ê° 10ëª… ì´ìƒ & ìŠ¹ê°ë‹¹ ì´ë™ 12íšŒ ë¯¸ë§Œ<br>
            â˜…â˜…â˜…â˜…â˜…: (í•˜ë“œ ëª¨ë“œ) ìŠ¹ê° 15ëª… ì´ìƒ & ìŠ¹ê°ë‹¹ ì´ë™ 8íšŒ ë¯¸ë§Œ
            <!-- 5ì„± ì¡°ê±´ì—ì„œ ì—°ë£Œí…œ ì¡°ê±´ì´ ì œê±°ë˜ì—ˆìŠµë‹ˆë‹¤ -->
        </div>
        <button id="tutorial-close-button">ë‹«ê¸°</button> 
    </div> </div>
    
    <div id="gameover-modal" class="modal"> <div class="modal-content"> <h2 id="gameover-title">ê²Œì„ ì˜¤ë²„!</h2> <p id="grade-display" style="font-size: 1.3em; font-weight: bold;"></p> <p id="grade-text" style="font-size: 1.1em;"></p> <div id="grade-details"></div> <button id="play-again-button">ë©”ì¸ ë©”ë‰´ë¡œ</button> </div> </div>
    
    <div id="mobile-controls"> <button id="btn-mobile-up">â–²</button> <button id="btn-mobile-left">â—€</button> <button id="btn-mobile-down">â–¼</button> <button id="btn-mobile-right">â–¶</button> </div>

    <script type="module">
        // (Firebase imports all removed)

        const GRID_SIZE = 10;
        const FUEL_REFILL_AMOUNT = 5;
        const NUM_BUILDINGS = 15;
        const NUM_PEDESTRIANS = 3;

        const DIFFICULTY = {
            EASY: { name: 'ì´ì§€', fuel: 25, pedestrians: false, fuelItems: 8, passengerRange: 2 }, // 6 -> 8
            NORMAL: { name: 'ë…¸ë§', fuel: 20, pedestrians: true, fuelItems: 6, passengerRange: 3 }, // 4 -> 6
            HARD: { name: 'í•˜ë“œ', fuel: 15, pedestrians: true, fuelItems: 5, passengerRange: 10 }, // 3 -> 5
        };
        
        const EMOJIS = { 
            TAXI: 'ğŸš–', PASSENGER: 'ğŸ§', FUEL: 'â›½',
            BUILDING: 'ğŸ¢', PEDESTRIAN: 'ğŸ‘¤', EMPTY: '',
            CHASER: 'ğŸ˜ˆ', EXIT: 'ğŸ', WALL: 'ğŸŒ²',
        };
        
        const ENTITY_TYPE = { 
            TAXI: 'TAXI', PASSENGER: 'PASSENGER', FUEL: 'FUEL',
            BUILDING: 'BUILDING', PEDESTRIAN: 'PEDESTRIAN',
            EMPTY: null, CHASER: 'CHASER', EXIT: 'EXIT', WALL: 'WALL',
        };
        
        // (Achievement list removed as it's no longer a tracked system)
        
        // --- Game State ---
        let board = [], taxiPos = { x: 0, y: 0 }, passengerPos = { x: 0, y: 0 };
        let pedestrianPositions = []; 
        let currentPath = []; 
        let isPracticeMode = false;
        let currentDifficulty = null, currentFuel = 0, passengersCount = 0, totalMoves = 0, fuelItemsCollected = 0;
        let gameActive = false, firstMoveTime = null;
        let hiddenStageActive = false;
        let playerHiddenPos = {x: 0, y: 0}, chaserPos = {x: 0, y: 0};
        let chaserInterval = null, hiddenTimeInterval = null, hiddenTimeLeft = 60;

        // --- Settings (Local state) ---
        let gameSettings = { 
            darkMode: false, 
            musicOn: true 
        };
        // --- Session State (Resets on refresh) ---
        let hiddenStageUnlocked = false; 

        // --- Hidden Stage Map ---
        const HIDDEN_GRID_SIZE = 16;
        const HIDDEN_MAP = [ "################", "#S..#......#...#", "#.#.#.####.#.#.#", "#.#...#....#.#X#", "#.###.####.#.#.#", "#...#.#......#.#", "###.#.#.######.#", "#.#...#........#", "#.#.#######.####", "#...#.....#....#", "#.#####.#.####.#", "#.#...#.#....#.#", "#.#.#.#.####.#.#", "#...#.....C....#", "################", "################" ];

        // --- DOM Elements ---
        const allDOMElements = {
            gameContainer: document.getElementById('game-container'), hiddenContainer: document.getElementById('hidden-stage-container'),
            gameBoard: document.getElementById('game-board'), hiddenBoard: document.getElementById('hidden-stage-board'),
            fuelDisplay: document.getElementById('fuel-display'), passengerDisplay: document.getElementById('passenger-display'),
            movesDisplay: document.getElementById('moves-display'), difficultyDisplay: document.getElementById('difficulty-display'),
            message: document.getElementById('message'),
            lobbyModal: document.getElementById('lobby-modal'), tutorialModal: document.getElementById('tutorial-modal'),
            difficultyModal: document.getElementById('difficulty-modal'), 
            gameoverModal: document.getElementById('gameover-modal'),
            gradeDisplay: document.getElementById('grade-display'), gradeText: document.getElementById('grade-text'), gradeDetails: document.getElementById('grade-details'),
            mobileControls: document.getElementById('mobile-controls'),
            mainTitle: document.getElementById('main-title'),
            toggleMusicBtn: document.getElementById('toggle-music'),
            toggleDarkModeBtn: document.getElementById('toggle-dark-mode'),
        };
        
        // --- Audio Context & SFX ---
        let audioContextStarted = false;
        let lobbyMusic, gameMusic;
        let musicGainNode;
        let sfx = {}; 

        async function initAudio() {
            if (audioContextStarted || (Tone.context && Tone.context.state === 'running')) return;
            try {
                await Tone.start();
                console.log("AudioContext started.");
                audioContextStarted = true;

                musicGainNode = new Tone.Gain(0.2).toDestination(); 
                const sfxGainNode = new Tone.Gain(0.4).toDestination(); 

                const lobbySynth = new Tone.PolySynth(Tone.AMSynth, {
                    harmonicity: 1.2,
                    oscillator: { type: "fatsine" },
                    envelope: { attack: 0.1, decay: 0.5, sustain: 0.3, release: 1.0 },
                    volume: -12
                }).connect(musicGainNode);
                
                const gameSynth = new Tone.MonoSynth({
                    oscillator: { type: "pulse", width: 0.6 },
                    envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.1 },
                    filterEnvelope: { attack: 0.01, decay: 0.05, sustain: 0, release: 0.1, baseFrequency: 300, octaves: 4 }
                }).connect(musicGainNode);

                lobbyMusic = new Tone.Sequence((time, note) => {
                    lobbySynth.triggerAttackRelease(note, "1n", time);
                }, ["C4", null, "G4", null, "E4", null, "F4", null, 
                    "C4", null, "G4", null, "E4", null, "D4", null], "2n").start(0);
                lobbyMusic.humanize = true;
                
                gameMusic = new Tone.Sequence((time, note) => {
                    gameSynth.triggerAttackRelease(note, "16n", time);
                }, ["C3", ["E3", "C3"], "G3", "E3", "C3", ["E3", "C3"], "G3", "E3"], "8n").start(0);
                gameMusic.loop = true;

                Tone.Transport.bpm.value = 90;
                Tone.Transport.start();
                stopAllMusic();

                sfx = {
                    move: new Tone.Synth({ oscillator: { type: 'sine' }, volume: -15, envelope: { attack: 0.005, decay: 0.05, sustain: 0, release: 0.1 } }).connect(sfxGainNode),
                    pickup: new Tone.Synth({ oscillator: { type: 'triangle' }, volume: -10, envelope: { attack: 0.01, decay: 0.1, sustain: 0.05, release: 0.1 } }).connect(sfxGainNode),
                    fuel: new Tone.Synth({ oscillator: { type: 'sawtooth' }, volume: -10, envelope: { attack: 0.01, decay: 0.1, sustain: 0.05, release: 0.1 } }).connect(sfxGainNode),
                    bump: new Tone.NoiseSynth({ noise: { type: 'brown' }, volume: -18, envelope: { attack: 0.01, decay: 0.1, sustain: 0, release: 0.1 } }).connect(sfxGainNode),
                    gameOver: new Tone.Synth({ oscillator: { type: 'square' }, volume: -10, envelope: { attack: 0.01, decay: 0.5, sustain: 0, release: 0.1 } }).connect(sfxGainNode),
                    win: new Tone.Synth({ oscillator: { type: 'sine' }, volume: -10, envelope: { attack: 0.01, decay: 0.2, sustain: 0, release: 0.1 } }).connect(sfxGainNode),
                };

            } catch (e) {
                console.warn("Audio context could not be started.", e);
            }
        }
        
        function playSfx(sound) {
            if (audioContextStarted && gameSettings.musicOn && sfx && sfx[sound]) {
                 try {
                    const now = Tone.now();
                    if (sound === 'pickup') {
                        sfx.pickup.triggerAttackRelease("C5", "16n", now);
                        sfx.pickup.triggerAttackRelease("G5", "16n", now + 0.1);
                    } else if (sound === 'fuel') {
                        sfx.fuel.triggerAttackRelease("E5", "16n", now);
                        sfx.fuel.triggerAttackRelease("A5", "16n", now + 0.1);
                    } else if (sound === 'move') {
                        sfx.move.triggerAttackRelease("C6", "32n", now);
                    } else if (sound === 'bump') {
                        sfx.bump.triggerAttackRelease("8n", now);
                    } else if (sound === 'gameOver') {
                        sfx.gameOver.triggerAttackRelease("C3", "4n", now);
                    } else if (sound === 'win') {
                        sfx.win.triggerAttackRelease("C5", "16n", now + 0);
                        sfx.win.triggerAttackRelease("E5", "16n", now + 0.1);
                        sfx.win.triggerAttackRelease("G5", "16n", now + 0.2);
                        sfx.win.triggerAttackRelease("C6", "8n", now + 0.3);
                    }
                } catch(e) {
                    console.warn("Error playing SFX:", e);
                }
            }
        }

        function playLobbyMusic() {
            if (!audioContextStarted || !gameSettings.musicOn || !lobbyMusic) return;
            if (gameMusic) gameMusic.stop();
            if (lobbyMusic.state !== "started") lobbyMusic.start(Tone.now());
        }

        function playGameMusic() {
            if (!audioContextStarted || !gameSettings.musicOn || !gameMusic) return;
            if (lobbyMusic) lobbyMusic.stop();
            if (gameMusic.state !== "started") gameMusic.start(Tone.now());
        }
        
        function stopAllMusic() {
            if (!audioContextStarted) return;
            if (lobbyMusic) lobbyMusic.stop();
            if (gameMusic) gameMusic.stop();
        }
        
        async function toggleMusic() {
            if (!audioContextStarted) await initAudio();
            gameSettings.musicOn = !gameSettings.musicOn;
            updateMusicButtonText();
            if (!gameSettings.musicOn) {
                stopAllMusic();
            } else {
                if (allDOMElements.lobbyModal.style.display === 'flex') {
                    playLobbyMusic();
                } else if (gameActive || hiddenStageActive) {
                    playGameMusic();
                }
            }
        }
        
        function updateMusicButtonText() {
            const btn = allDOMElements.toggleMusicBtn;
            if (btn) {
                btn.textContent = `ìŒì•…: ${gameSettings.musicOn ? 'ì¼œê¸°' : 'ë„ê¸°'}`;
            }
        }

        function toggleDarkMode() {
            gameSettings.darkMode = !gameSettings.darkMode;
            applyTheme(gameSettings.darkMode);
            updateDarkModeButtonText();
        }

        function updateDarkModeButtonText() {
            const btn = allDOMElements.toggleDarkModeBtn;
            if(btn) {
                btn.textContent = `í…Œë§ˆ: ${gameSettings.darkMode ? 'ë‹¤í¬' : 'ë¼ì´íŠ¸'}`;
            }
        }
        
        // --- Event Listeners Setup ---
        function setupEventListeners() {
            // Lobby Buttons
            document.getElementById('btn-play').onclick = () => showDifficultyModal(false);
            document.getElementById('btn-practice').onclick = () => showDifficultyModal(true); 
            document.getElementById('btn-tutorial').onclick = showTutorialFromLobby;
            document.getElementById('btn-hidden-stage').onclick = startHiddenStage;
            // Removed settings/achievements listeners

            // Difficulty Modal Buttons
            document.getElementById('btn-easy').onclick = () => selectDifficulty(DIFFICULTY.EASY);
            document.getElementById('btn-normal').onclick = () => selectDifficulty(DIFFICULTY.NORMAL);
            document.getElementById('btn-hard').onclick = () => selectDifficulty(DIFFICULTY.HARD);
            document.getElementById('btn-difficulty-back').onclick = () => hideModal(allDOMElements.difficultyModal);

            // Other Modals
            document.getElementById('tutorial-close-button').onclick = () => hideModal(allDOMElements.tutorialModal);
            document.getElementById('play-again-button').onclick = showLobby;
            document.getElementById('main-menu-button').onclick = showLobby;
            document.getElementById('hidden-main-menu-button').onclick = showLobby;
            
            // Settings buttons in lobby
            allDOMElements.toggleDarkModeBtn.onclick = toggleDarkMode;
            allDOMElements.toggleMusicBtn.onclick = toggleMusic; 
            
            // Mobile controls listeners
            document.getElementById('btn-mobile-up').onclick = () => handleMoveInput(0, -1);
            document.getElementById('btn-mobile-down').onclick = () => handleMoveInput(0, 1);
            document.getElementById('btn-mobile-left').onclick = () => handleMoveInput(-1, 0);
            document.getElementById('btn-mobile-right').onclick = () => handleMoveInput(1, 0);

            // Keyboard listener
            document.addEventListener('keydown', (e) => {
                const isModalVisible = 
                                    allDOMElements.lobbyModal.style.display === 'flex' ||
                                    allDOMElements.tutorialModal.style.display === 'flex' ||
                                    allDOMElements.difficultyModal.style.display === 'flex';
                
                const canAcceptInput = gameActive || hiddenStageActive;
                
                if (!canAcceptInput || isModalVisible) return; // Block input if a modal is up
                
                if (allDOMElements.gameoverModal.style.display === 'flex') {
                    if(e.key === 'Enter') showLobby();
                    return;
                }
                
                if (gameActive) handleNormalGameInput(e.key);
                else if (hiddenStageActive) handleHiddenStageInput(e.key);
            });
            
            // Single click listener to init audio
            document.body.addEventListener('click', initAudio, { once: true });
        }

        const isMobile = () => /Mobi/i.test(window.navigator.userAgent);
        
        function showModal(modal) { 
            // Hide all modals
            allDOMElements.lobbyModal.style.display = 'none';
            allDOMElements.tutorialModal.style.display = 'none';
            allDOMElements.difficultyModal.style.display = 'none';
            allDOMElements.gameoverModal.style.display = 'none';
            
            if (modal) modal.style.display = 'flex'; 
        }
        
        function hideModal(modal) { 
            if (modal) modal.style.display = 'none'; 
            allDOMElements.lobbyModal.style.display = 'flex';
        }
        
        function disableLobbyButtons(disabled) {
            // Re-query lobby buttons as they are not in allDOMElements
            document.querySelectorAll('#lobby-modal .difficulty-buttons button').forEach(button => {
                if(button) button.disabled = disabled; 
            });
       }

        function showLobby() { 
            gameActive = false; hiddenStageActive = false;
            clearInterval(chaserInterval); clearInterval(hiddenTimeInterval);
            
            allDOMElements.gameContainer.style.display = 'none';
            allDOMElements.hiddenContainer.style.display = 'none';
            allDOMElements.mobileControls.style.display = 'none';
            
            showModal(allDOMElements.lobbyModal);
            allDOMElements.mainTitle.style.display = 'block';

            document.getElementById('btn-hidden-stage').style.display = hiddenStageUnlocked ? 'block' : 'none';
            disableLobbyButtons(false); // Enable lobby buttons
            
            playLobbyMusic();
        }

        function showDifficultyModal(practice) {
            isPracticeMode = practice;
            document.getElementById('difficulty-modal-title').textContent = practice ? "ì—°ìŠµ ëª¨ë“œ ë‚œì´ë„" : "ë‚œì´ë„ ì„ íƒ";
            showModal(allDOMElements.difficultyModal);
        }

        function selectDifficulty(difficulty) { 
            currentDifficulty = { ...difficulty }; 
            if (isPracticeMode) {
                currentDifficulty.name = `ì—°ìŠµ (${difficulty.name})`; 
            }
            startGame();
        }

        function showTutorialFromLobby() { 
            showModal(allDOMElements.tutorialModal);
        }

        function startGame() { 
            allDOMElements.tutorialModal.style.display = 'none';
            allDOMElements.difficultyModal.style.display = 'none'; 
            allDOMElements.gameContainer.style.display = 'flex';
            allDOMElements.mainTitle.style.display = 'none';
            if (isMobile()) allDOMElements.mobileControls.style.display = 'grid';
            initializeGame();
        }

        function initializeGame() { 
            currentFuel = currentDifficulty.fuel;
            passengersCount = 0; totalMoves = 0; fuelItemsCollected = 0;
            firstMoveTime = null;
            pedestrianPositions = []; 
            currentPath = []; 
            taxiPos = { x: Math.floor(GRID_SIZE / 2), y: Math.floor(GRID_SIZE / 2) };
            allDOMElements.difficultyDisplay.textContent = currentDifficulty.name;
            allDOMElements.message.textContent = '';
            
            generateMap(); 
            if (isPracticeMode) calculatePath(); 
            
            renderBoard(); 
            updateHUD();
            gameActive = true;
            playGameMusic();
        }
        
        // **REWRITTEN: Map generation logic**
        function generateMap() {
            board = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(ENTITY_TYPE.EMPTY));
            
            const startX = Math.floor(GRID_SIZE / 2);
            const startY = Math.floor(GRID_SIZE / 2);
            taxiPos = { x: startX, y: startY }; 

            let availableCoords = [];
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    if (y !== startY || x !== startX) { 
                        availableCoords.push({x, y});
                    }
                }
            }
            
            availableCoords.sort(() => Math.random() - 0.5); 

            // Function to safely place multiple entities
            const placeEntities = (type, count, storageArray = null) => {
                let placedCount = 0;
                for (let i = 0; i < count; i++) {
                    if (availableCoords.length === 0) {
                        console.warn(`Ran out of space to place ${type}`);
                        break;
                    }
                    const pos = availableCoords.pop(); 
                    board[pos.y][pos.x] = type;
                    if (storageArray) storageArray.push({x: pos.x, y: pos.y}); 
                    placedCount++;
                }
            };

            // --- 
            // --- 
            // --- BUG FIX: Place obstacles FIRST ---
            // --- 
            // --- 
            
            // 1. Place obstacles FIRST
            placeEntities(ENTITY_TYPE.BUILDING, NUM_BUILDINGS, null); 
            if (currentDifficulty.pedestrians) {
                pedestrianPositions = []; 
                placeEntities(ENTITY_TYPE.PEDESTRIAN, NUM_PEDESTRIANS, pedestrianPositions);
            }
            
            // 'availableCoords' now contains ONLY empty cells

            // 2. Find a VALID, REACHABLE spot for the passenger
            passengerPos = null;
            const obstacles = [ENTITY_TYPE.BUILDING, ENTITY_TYPE.PEDESTRIAN];
            const range = currentDifficulty.passengerRange;
            
            let validPassengerSpots = [];
            let otherReachableSpots = [];

            // Iterate through all remaining empty spots to check reachability
            for (const pos of availableCoords) {
                // Run pathfinder to check reachability
                const path = findPathBFS(taxiPos, pos, GRID_SIZE, board, obstacles);
                
                if (path !== null) { // If it's reachable...
                    const dist = Math.abs(pos.x - taxiPos.x) + Math.abs(pos.y - taxiPos.y);
                    // Check if it's within the difficulty's preferred range
                    if (dist <= range) {
                        validPassengerSpots.push(pos);
                    } else {
                        otherReachableSpots.push(pos);
                    }
                }
                // If path === null, the spot is unreachable, so we ignore it.
            }
            
            // 3. Prioritize spots within range
            if (validPassengerSpots.length > 0) {
                // Pick a random spot from the "good" list (in range)
                passengerPos = validPassengerSpots[Math.floor(Math.random() * validPassengerSpots.length)];
            } else if (otherReachableSpots.length > 0) {
                // No spot in range, pick any reachable spot
                console.warn("No reachable passenger spot found *within range*. Placing at any reachable spot.");
                passengerPos = otherReachableSpots[Math.floor(Math.random() * otherReachableSpots.length)];
            } else {
                // No reachable spots AT ALL (taxi is boxed in)
                console.error("FATAL: Taxi is completely boxed in by buildings. No reachable spot for passenger.");
                // Fallback: just grab the first available coord, even if unreachable
                if (availableCoords.length > 0) {
                     passengerPos = availableCoords[0]; 
                } else {
                    // This should be impossible, but...
                    passengerPos = {x: 0, y: 0}; 
                    if (board[0][0] === ENTITY_TYPE.TAXI) passengerPos = {x: 1, y: 0};
                }
            }

            // 4. Place the passenger and remove from availableCoords
            if (passengerPos) {
                board[passengerPos.y][passengerPos.x] = ENTITY_TYPE.PASSENGER;
                const indexToRemove = availableCoords.findIndex(p => p.x === passengerPos.x && p.y === passengerPos.y);
                if (indexToRemove > -1) {
                    availableCoords.splice(indexToRemove, 1);
                }
            } else {
                // Fallback if passengerPos is still null (shouldn't happen)
                 if (availableCoords.length > 0) {
                     passengerPos = availableCoords.splice(0, 1)[0];
                     board[passengerPos.y][passengerPos.x] = ENTITY_TYPE.PASSENGER;
                 } else {
                     console.error("CRITICAL: No space left to place passenger!");
                     board[0][0] = ENTITY_TYPE.PASSENGER;
                     passengerPos = {x: 0, y: 0};
                 }
            }
            
            // (The old passenger placement logic has been removed)

            // --- 
            // --- END OF BUG FIX ---
            // --- 

            // --- NEW FUEL PLACEMENT LOGIC (from previous steps) ---
            // 'availableCoords'ëŠ” ì´ì œ íƒì‹œ, ìŠ¹ê°, ê±´ë¬¼, ë³´í–‰ìë¥¼ ì œì™¸í•œ ëª¨ë“  ë¹ˆì¹¸ ëª©ë¡ì…ë‹ˆë‹¤.
            
            const fuelToPlace = currentDifficulty.fuelItems;
            let fuelPlaced = 0;

            const TOO_CLOSE_DIST = 1; // ë§¨í•´íŠ¼ ê±°ë¦¬ 1 (ë„ˆë¬´ ê°€ê¹Œì›€)
            const NEAR_DIST_MAX = 4; // ë§¨í•´íŠ¼ ê±°ë¦¬ 2, 3, 4 (ê°€ê¹Œì›€)

            let nearSpots = [];
            let otherSpots = [];

            const MAX_NEAR_FUEL = 2; // ìŠ¹ê° ê·¼ì²˜ì— ë°°ì¹˜í•  ìµœëŒ€ ì—°ë£Œ ìˆ˜
            let nearFuelPlaced = 0; // ìŠ¹ê° ê·¼ì²˜ì— ë°°ì¹˜í•œ ì—°ë£Œ ìˆ˜

            // 1. ë‚¨ì€ ë¹ˆì¹¸ë“¤ì„ "ê°€ê¹Œìš´ ê³³"ê³¼ "ë‹¤ë¥¸ ê³³" ë‘ ëª©ë¡ìœ¼ë¡œ ë¶„ë¥˜í•©ë‹ˆë‹¤.
            availableCoords.forEach(pos => {
                const dist = Math.abs(pos.x - passengerPos.x) + Math.abs(pos.y - passengerPos.y);
                if (dist > TOO_CLOSE_DIST && dist <= NEAR_DIST_MAX) {
                    nearSpots.push(pos);
                } else {
                    otherSpots.push(pos);
                }
            });

            // 2. ë‘ ëª©ë¡ì„ ê°ê° ë¬´ì‘ìœ„ë¡œ ì„ìŠµë‹ˆë‹¤.
            nearSpots.sort(() => Math.random() - 0.5);
            otherSpots.sort(() => Math.random() - 0.5);

            // 3. "ê°€ê¹Œìš´ ê³³" ëª©ë¡ì—ì„œ ë¨¼ì € ì—°ë£Œë¥¼ ë°°ì¹˜í•©ë‹ˆë‹¤.
            while (fuelPlaced < fuelToPlace && nearSpots.length > 0 && nearFuelPlaced < MAX_NEAR_FUEL) {
                const pos = nearSpots.pop();
                board[pos.y][pos.x] = ENTITY_TYPE.FUEL;
                fuelPlaced++;
                nearFuelPlaced++; // ê·¼ì²˜ì— ë°°ì¹˜í•œ ì¹´ìš´íŠ¸ ì¦ê°€
            }

            // 4. ì•„ì§ ë°°ì¹˜í•  ì—°ë£Œê°€ ë‚¨ì•˜ë‹¤ë©´ "ë‹¤ë¥¸ ê³³" ëª©ë¡ì—ì„œ ë°°ì¹˜í•©ë‹ˆë‹¤.
            while (fuelPlaced < fuelToPlace && otherSpots.length > 0) {
                const pos = otherSpots.pop();
                board[pos.y][pos.x] = ENTITY_TYPE.FUEL;
                fuelPlaced++;
            }
            
            // 5. ë§Œì•½ ëª¨ë“  ë¹ˆì¹¸ì„ ë‹¤ ì¼ëŠ”ë°ë„ ì—°ë£Œë¥¼ ëœ ë°°ì¹˜í–ˆë‹¤ë©´ ê²½ê³ ë¥¼ ì¶œë ¥í•©ë‹ˆë‹¤.
            if (fuelPlaced < fuelToPlace) {
                console.warn(`Could not place all ${fuelToPlace} fuel items. Only placed ${fuelPlaced}.`);
            }
            // --- END OF NEW FUEL PLACEMENT LOGIC ---
            
            // Finally, place the taxi
            board[taxiPos.y][taxiPos.x] = ENTITY_TYPE.TAXI;
        }
        
        function renderBoard() { 
            allDOMElements.gameBoard.innerHTML = '';
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    const cellEntityType = board[y][x]; 
                    
                    if (cellEntityType) {
                        cell.textContent = EMOJIS[cellEntityType] || ''; 
                    } else {
                        cell.textContent = EMOJIS.EMPTY;
                    }

                    cell.classList.remove('path'); 
                    if (isPracticeMode && currentPath && currentPath.length > 0 && currentPath.some(p => p.x === x && p.y === y)) {
                        if (cellEntityType !== ENTITY_TYPE.TAXI && cellEntityType !== ENTITY_TYPE.PASSENGER) {
                            cell.classList.add('path');
                        }
                    }

                    allDOMElements.gameBoard.appendChild(cell);
                }
            }
        }

        function updateHUD() { 
            allDOMElements.fuelDisplay.textContent = currentFuel;
            allDOMElements.passengerDisplay.textContent = passengersCount;
            allDOMElements.movesDisplay.textContent = totalMoves;
        }

        function handleMoveInput(dx, dy) { 
            if (gameActive) moveTaxi(dx, dy);
            else if (hiddenStageActive) moveHiddenTaxi(dx, dy);
        }
        
        function handleNormalGameInput(key) { 
             const lowerKey = key.toLowerCase();
             // Combined WASD and Arrow Keys
             if (lowerKey === 'w' || lowerKey === 'arrowup') handleMoveInput(0, -1);
             else if (lowerKey === 's' || lowerKey === 'arrowdown') handleMoveInput(0, 1);
             else if (lowerKey === 'a' || lowerKey === 'arrowleft') handleMoveInput(-1, 0);
             else if (lowerKey === 'd' || lowerKey === 'arrowright') handleMoveInput(1, 0);
        }
        
        function movePedestrians() { 
            let currentPedPositions = [];
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    if (board[y][x] === ENTITY_TYPE.PEDESTRIAN) currentPedPositions.push({x, y});
                }
            }
            
            currentPedPositions.sort(() => Math.random() - 0.5); 

            currentPedPositions.forEach(pos => {
                if (board[pos.y][pos.x] !== ENTITY_TYPE.PEDESTRIAN) return;

                const possibleMoves = [];
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        if (dx === 0 && dy === 0) continue;
                        const newX = pos.x + dx, newY = pos.y + dy;
                        if (newX >= 0 && newX < GRID_SIZE && newY >= 0 && newY < GRID_SIZE && 
                            board[newY][newX] === ENTITY_TYPE.EMPTY) {
                            possibleMoves.push({x: newX, y: newY});
                        }
                    }
                }
                if (possibleMoves.length > 0) {
                    const move = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                    board[pos.y][pos.x] = ENTITY_TYPE.EMPTY;
                    board[move.y][move.x] = ENTITY_TYPE.PEDESTRIAN;
                }
            });
        }
        
        function moveTaxi(dx, dy) { 
            if (!gameActive || currentFuel <= 0) return; 
            if (!firstMoveTime) firstMoveTime = Date.now();
            const newX = taxiPos.x + dx, newY = taxiPos.y + dy;
            if (newX < 0 || newX >= GRID_SIZE || newY < 0 || newY >= GRID_SIZE) {
                allDOMElements.message.textContent = 'ë²½ì— ë¶€ë”ªí˜”ìŠµë‹ˆë‹¤!'; 
                playSfx('bump');
                return;
            }
            
            // --- ìˆ˜ì •ëœ ë¶€ë¶„ (from previous step) ---
            const destination = board[newY][newX];

            // 1. ê±´ë¬¼ê³¼ ì¶©ëŒ
            if (destination === ENTITY_TYPE.BUILDING) {
                allDOMElements.message.textContent = 'í†µê³¼í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤!'; 
                playSfx('bump');
                return; // ì´ë™ ì•ˆ í•¨, ì—°ë£Œ ì†Œëª¨ ì—†ìŒ
            }

            // 2. ë³´í–‰ìì™€ ì¶©ëŒ (í˜ë„í‹°)
            if (destination === ENTITY_TYPE.PEDESTRIAN) {
                allDOMElements.message.textContent = 'ë³´í–‰ì ì£¼ì˜! (ì—°ë£Œ -1)'; 
                playSfx('bump');
                
                currentFuel--; // í˜ë„í‹°ë¡œ ì—°ë£Œ 1 ì†Œëª¨
                totalMoves++; // ì´ë™ ì‹œë„ë¡œ ê°„ì£¼
                
                updateHUD(); // HUD ì—…ë°ì´íŠ¸

                if (currentFuel <= 0) {
                    gameOver('ì—°ë£Œ ê³ ê°ˆ!');
                }
                
                return; // ì´ë™ ì•ˆ í•¨
            }
            // --- ìˆ˜ì • ë ---


            playSfx('move');
            board[taxiPos.y][taxiPos.x] = ENTITY_TYPE.EMPTY;
            taxiPos = { x: newX, y: newY };
            currentFuel--; totalMoves++; allDOMElements.message.textContent = '';
            let shouldGenerateNewMap = false;

            if (destination === ENTITY_TYPE.PASSENGER) {
                playSfx('pickup');
                passengersCount++; 
                // if (!isPracticeMode) playerData.totalPassengers++; // Removed
                allDOMElements.message.textContent = `ìŠ¹ê° ${passengersCount}ëª… íƒ‘ìŠ¹!`;
                // Removed achievement checks
                shouldGenerateNewMap = true;
            } else if (destination === ENTITY_TYPE.FUEL) {
                playSfx('fuel');
                currentFuel += FUEL_REFILL_AMOUNT; fuelItemsCollected++;
                allDOMElements.message.textContent = `ì—°ë£Œ +${FUEL_REFILL_AMOUNT} íšŒë³µ!`;
            } 
            
            board[taxiPos.y][taxiPos.x] = ENTITY_TYPE.TAXI;
            
            if (currentDifficulty.pedestrians) {
                movePedestrians();
                if(board[taxiPos.y][taxiPos.x] !== ENTITY_TYPE.TAXI) {
                     board[taxiPos.y][taxiPos.x] = ENTITY_TYPE.TAXI;
                }
            }

            if(shouldGenerateNewMap) { 
                generateMap(); 
            }
            
            if (isPracticeMode) calculatePath(); 
            renderBoard(); updateHUD();

            if (currentFuel <= 0) {
                 // Removed achievement check
                gameOver('ì—°ë£Œ ê³ ê°ˆ!');
            }
        }

        function gameOver(reason) { 
            gameActive = false;
            stopAllMusic(); 
            playLobbyMusic(); 
            playSfx('gameOver');
            document.getElementById('gameover-title').textContent = reason;
            calculateGrade();
            // Removed saveGameData()
            showModal(allDOMElements.gameoverModal);
        }

        // --- 
        // --- THIS IS THE (PREVIOUSLY) UPDATED FUNCTION ---
        // --- (No changes here, this is the correct version)
        // --- 
        function calculateGrade() { 
            if (isPracticeMode) { 
                if (passengersCount === 0) {
                    allDOMElements.gradeDisplay.textContent = "ì—°ìŠµ";
                    allDOMElements.gradeText.textContent = "ì—°ìŠµ ì™„ë£Œ!";
                    allDOMElements.gradeDetails.innerHTML = `â€¢ íƒœìš´ ìŠ¹ê°: 0ëª…`;
                    return;
                }
                const movesPerPassenger = totalMoves > 0 ? (totalMoves / passengersCount).toFixed(1) : 0;
                allDOMElements.gradeDisplay.textContent = "ì—°ìŠµ";
                allDOMElements.gradeText.textContent = "ì—°ìŠµ ì™„ë£Œ!";
                allDOMElements.gradeDetails.innerHTML = `â€¢ <strong>íƒœìš´ ìŠ¹ê°</strong>: ${passengersCount}ëª…<br> â€¢ <strong>ì´ë™ íš¨ìœ¨</strong>: ìŠ¹ê°ë‹¹ ${movesPerPassenger}íšŒ ì´ë™<br> â€¢ <strong>ì—°ë£Œí…œ ì‚¬ìš©</strong>: ${fuelItemsCollected}ê°œ`;
                return;
            }

            // --- Real Grade Calculation (if not practice mode) ---
            if (passengersCount === 0) {
                allDOMElements.gradeDisplay.textContent = "â˜†â˜†â˜†â˜†â˜†";
                allDOMElements.gradeText.textContent = "ë‹¤ìŒì—” ê¼­ ìŠ¹ê°ì„ íƒœì›Œë³´ì„¸ìš”!";
                allDOMElements.gradeDetails.innerHTML = `â€¢ íƒœìš´ ìŠ¹ê°: 0ëª…`;
                return;
            }

            // 1. [ë²„ê·¸ ìˆ˜ì •] ë¹„êµë¥¼ ìœ„í•´ ìˆœìˆ˜í•œ 'ìˆ«ì'ë¡œ ë¨¼ì € ê³„ì‚°í•©ë‹ˆë‹¤.
            const movesPerPassenger_Num = (passengersCount > 0) ? (totalMoves / passengersCount) : 0;
            
            // 2. [ë¡œì§ ìˆ˜ì •] ë³„ì ì„ 0ì—ì„œë¶€í„° ëˆ„ì í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ ë³€ê²½ (ë” ëª…í™•í•¨)
            let totalStars = 0;
            if (passengersCount >= 1) totalStars = 1;
            if (passengersCount >= 3) totalStars = 2;
            if (passengersCount >= 6) totalStars = 3;
            
            // [ë²„ê·¸ ìˆ˜ì •] 'movesPerPassenger_Num' (ìˆ«ì)ë¡œ ë¹„êµ
            if (passengersCount >= 10 && movesPerPassenger_Num < 12) totalStars = 4;
            
            // 3. [ìš”ì²­ ì‚¬í•­] 5ì„± ì¡°ê±´ì—ì„œ 'fuelItemsCollected === 0' ì œê±°
            if (currentDifficulty.name === DIFFICULTY.HARD.name && 
                passengersCount >= 15 && 
                movesPerPassenger_Num < 8) { //
                totalStars = 5;
            }

            const starString = 'â˜…'.repeat(totalStars) + 'â˜†'.repeat(5 - totalStars);
            
            if(totalStars >= 5) {
                if (!hiddenStageUnlocked) {
                    hiddenStageUnlocked = true;
                    
                    // playSfx('achievement'); // 'achievement'ê°€ sfx ê°ì²´ì— ì •ì˜ë˜ì§€ ì•Šì•„ ì˜¤ë¥˜ ë°œìƒ ê°€ëŠ¥
                    
                    const toast = document.createElement('div');
                    // (ì„ì‹œ ìŠ¤íƒ€ì¼ë§: CSSê°€ ì—†ì–´ë„ ë³´ì´ë„ë¡)
                    toast.style.cssText = `
                        position: fixed;
                        left: 50%;
                        transform: translateX(-50%);
                        bottom: 20px;
                        background-color: #6f42c1;
                        color: white;
                        padding: 15px 25px;
                        border-radius: 10px;
                        font-weight: bold;
                        z-index: 2000;
                        opacity: 0;
                        transition: opacity 0.5s, bottom 0.5s;
                    `;
                    
                    toast.textContent = "âœ¨ íˆë“  ìŠ¤í…Œì´ì§€ê°€ í•´ê¸ˆë˜ì—ˆìŠµë‹ˆë‹¤! âœ¨";
                    document.body.appendChild(toast);
                    setTimeout(() => {
                        toast.style.opacity = '1';
                        toast.style.bottom = '40px';
                    }, 100);
                    setTimeout(() => {
                        toast.style.opacity = '0';
                        toast.style.bottom = '20px';
                        setTimeout(() => toast.remove(), 500);
                    }, 3000);
                }
            }
            
            let title = "";
            switch(totalStars) {
                case 5: title = "ì „ì„¤ì˜ ë² ìŠ¤íŠ¸ ë“œë¼ì´ë²„!"; break;
                case 4: title = "í™˜ìƒì ì¸ íƒì‹œ ìš´ì „ì‚¬!"; break;
                case 3: title = "í›Œë¥­í•œ ë² í…Œë‘ ê¸°ì‚¬ë‹˜!"; break;
                case 2: title = "ì„±ì¥í•˜ëŠ” ëª¨ë²” ê¸°ì‚¬ë‹˜!"; break;
                case 1: title = "ì´ì œ ë§‰ ì‹œì‘í•˜ëŠ” ì‹ ì…!"; break;
                default: title = "ë‹¤ì‹œ ë„ì „í•´ë³´ì„¸ìš”!";
            }
            
            // 4. [ë²„ê·¸ ìˆ˜ì •] í™”ë©´ì—ëŠ” .toFixed(1)ì´ ì ìš©ëœ 'ë¬¸ìì—´'ì„ ì‚¬ìš©
            const movesPerPassenger_Display = movesPerPassenger_Num.toFixed(1);
            
            allDOMElements.gradeDisplay.textContent = starString; 
            allDOMElements.gradeText.textContent = title;
            allDOMElements.gradeDetails.innerHTML = `â€¢ <strong>íƒœìš´ ìŠ¹ê°</strong>: ${passengersCount}ëª…<br> â€¢ <strong>ì´ë™ íš¨ìœ¨</strong>: ìŠ¹ê°ë‹¹ ${movesPerPassenger_Display}íšŒ ì´ë™<br> â€¢ <strong>ì—°ë£Œí…œ ì‚¬ìš©</strong>: ${fuelItemsCollected}ê°œ`;
        }
        
        function showAchievements() { 
            alert("ë¡œê·¸ì¸/ì €ì¥ ê¸°ëŠ¥ì´ ì œê±°ë˜ì–´ ë„ì „ê³¼ì œë¥¼ ì´ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
        }
        
        function applyTheme(isDarkMode) { 
             document.body.classList.toggle('dark-mode', isDarkMode);
        }

        function showSettings() { 
            alert("ë¡œê·¸ì¸/ì €ì¥ ê¸°ëŠ¥ì´ ì œê±°ë˜ì–´ ì„¤ì •ì„ ì´ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
        }
        
        function saveAndCloseSettings() { 
            hideModal(allDOMElements.settingsModal);
        }
        
        // --- Hidden Stage Functions ---
        function startHiddenStage() { 
             allDOMElements.lobbyModal.style.display = 'none';
            allDOMElements.hiddenContainer.style.display = 'flex';
            if (isMobile()) allDOMElements.mobileControls.style.display = 'grid';
            allDOMElements.mainTitle.style.display = 'none';
            initializeHiddenStage();
        }
        function initializeHiddenStage() { 
            for(let y=0; y<HIDDEN_MAP.length; y++) for(let x=0; x<HIDDEN_MAP[y].length; x++) {
                if (HIDDEN_MAP[y][x] === 'S') playerHiddenPos = {x, y}; 
                if (HIDDEN_MAP[y][x] === 'C') chaserPos = {x, y};
            }
            hiddenTimeLeft = 60; document.getElementById('time-display').textContent = hiddenTimeLeft;
            renderHiddenStage(); hiddenStageActive = true;
            playGameMusic(); 
            chaserInterval = setInterval(moveChaser, 1000);
            hiddenTimeInterval = setInterval(() => {
                if(!hiddenStageActive) return; 
                hiddenTimeLeft--; 
                document.getElementById('time-display').textContent = hiddenTimeLeft;
                if (hiddenTimeLeft <= 0) gameOverHidden('ì‹œê°„ ì´ˆê³¼!');
            }, 1000);
        }
        function renderHiddenStage() { 
            allDOMElements.hiddenBoard.innerHTML = '';
            for(let y=0; y<HIDDEN_GRID_SIZE; y++) for(let x=0; x<HIDDEN_GRID_SIZE; x++) {
                const cell = document.createElement('div'); cell.classList.add('hidden-cell');
                const tile = HIDDEN_MAP[y][x];
                if (tile === '#') {
                    cell.classList.add('wall'); 
                    cell.textContent = EMOJIS.WALL; 
                } else if (tile === 'X') {
                    cell.textContent = EMOJIS.EXIT;
                }
                
                if (x === chaserPos.x && y === chaserPos.y) {
                    cell.textContent = EMOJIS.CHASER;
                }
                if (x === playerHiddenPos.x && y === playerHiddenPos.y) {
                    cell.textContent = EMOJIS.TAXI; 
                }
                allDOMElements.hiddenBoard.appendChild(cell);
            }
        }
        function handleHiddenStageInput(key) { 
            const lowerKey = key.toLowerCase();
            if (lowerKey === 'w' || lowerKey === 'arrowup') handleMoveInput(0, -1);
            else if (lowerKey === 's' || lowerKey === 'arrowdown') handleMoveInput(0, 1);
            else if (lowerKey === 'a' || lowerKey === 'arrowleft') handleMoveInput(-1, 0);
            else if (lowerKey === 'd' || lowerKey === 'arrowright') handleMoveInput(1, 0);
        }
        function moveHiddenTaxi(dx, dy){ 
            if(!hiddenStageActive) return;
            const newX = playerHiddenPos.x + dx, newY = playerHiddenPos.y + dy;
            if (newY >=0 && newY < HIDDEN_GRID_SIZE && newX >=0 && newX < HIDDEN_GRID_SIZE && HIDDEN_MAP[newY][newX] !== '#') {
                playSfx('move'); 
                playerHiddenPos = {x: newX, y: newY};
                renderHiddenStage(); 
                checkHiddenStageConditions(); 
            } else {
                 playSfx('bump'); 
            }
        }
        function moveChaser() { 
             if(!hiddenStageActive) return;
             const path = findPathBFS(chaserPos, playerHiddenPos, HIDDEN_GRID_SIZE, HIDDEN_MAP.map(row => row.split('')), ['#']);
            if (path && path.length > 0) {
                chaserPos = path.shift() || chaserPos; 
                if (path.length > 0) { 
                    chaserPos = path.shift(); 
                }
            }
            renderHiddenStage(); 
            checkHiddenStageConditions(); 
        }
        function checkHiddenStageConditions() { 
             if (playerHiddenPos.x === chaserPos.x && playerHiddenPos.y === chaserPos.y) {
                 gameOverHidden('ì¶”ê²©ìì—ê²Œ ì¡í˜”ìŠµë‹ˆë‹¤!');
             }
            if(HIDDEN_MAP[playerHiddenPos.y][playerHiddenPos.x] === 'X') {
                gameOverHidden('íƒˆì¶œ ì„±ê³µ!', true);
            }
        }
        function gameOverHidden(reason, isWin = false) { 
             if (!hiddenStageActive) return;
            hiddenStageActive = false;
            stopAllMusic(); 
            playLobbyMusic(); 
            clearInterval(chaserInterval); clearInterval(hiddenTimeInterval);
            
            if (isWin) { 
                playSfx('win');
            } else {
                playSfx('gameOver');
            }
            
            document.getElementById('gameover-title').textContent = reason;
            allDOMElements.gradeDisplay.textContent = isWin ? "ğŸ‰ğŸ‰ğŸ‰" : "ğŸ˜¥";
            allDOMElements.gradeText.textContent = isWin ? "ë‹¹ì‹ ì€ ì§„ì •í•œ ì¶”ê²©ì˜ ë‹¬ì¸!" : "ì¡°ê¸ˆë§Œ ë” í˜ë‚´ì„¸ìš”!";
            allDOMElements.gradeDetails.innerHTML = isWin ? `â€¢ ë¹„ë°€ ìŠ¤í…Œì´ì§€ í´ë¦¬ì–´!` : `â€¢ ì•„ì‰½ê²Œ íƒˆì¶œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.`;
            showModal(allDOMElements.gameoverModal);
        }
        
        // --- 
        // --- 
        // --- THIS IS THE START OF THE MODIFICATIONS ---
        // --- 
        // --- 
        
        // (ì´ í•¨ìˆ˜(findPathBFS)ëŠ” íˆë“  ìŠ¤í…Œì´ì§€ì˜ ì¶”ê²©ì AIê°€ ì‚¬ìš©í•˜ë¯€ë¡œ ìˆ˜ì •í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤)
        // (ë˜í•œ generateMapì˜ ë²„ê·¸ ìˆ˜ì •ì—ë„ ì‚¬ìš©ë©ë‹ˆë‹¤)
        function findPathBFS(start, end, size, mapData, obstacles) { 
            const queue = [{ ...start, path: [] }], visited = new Set([`${start.x},${start.y}`]);
            const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]; 

            while (queue.length > 0) {
                const { x, y, path } = queue.shift();
                if (x === end.x && y === end.y) return path;
                for (const [dx, dy] of directions) {
                    const newX = x + dx, newY = y + dy;
                    if (newX < 0 || newX >= size || newY < 0 || newY >= size) continue; 

                    const key = `${newX},${newY}`;
                    const tile = Array.isArray(mapData[0]) ? mapData[newY][newX] : mapData[newY].charAt(newX); 
                    
                    if (!obstacles.includes(tile) && !visited.has(key)) {
                        visited.add(key); 
                        queue.push({ x: newX, y: newY, path: [...path, {x: newX, y: newY}] });
                    }
                }
            }
            return null; // No path found
        }
        
        // --- NEW FUNCTION ADDED (from previous step) ---
        // ì—°ë£Œë¥¼ ìš°ì„ ì‹œí•˜ëŠ” Dijkstra ê¸°ë°˜ ê²½ë¡œ íƒìƒ‰ê¸°
        function findFuelPathDijkstra(start, end, size, mapData, obstacles) {
            // ìš°ì„ ìˆœìœ„ í: { x, y, cost, path: [] }
            // ê°„ë‹¨í•œ ë°°ì—´ì„ ì •ë ¬í•˜ì—¬ ìš°ì„ ìˆœìœ„ íë¥¼ ì‹œë®¬ë ˆì´ì…˜í•©ë‹ˆë‹¤.
            const priorityQueue = [{ ...start, cost: 0, path: [] }];
            
            // ê° ì…€ì— ë„ë‹¬í•˜ëŠ” ë° ë“œëŠ” ìµœì†Œ ë¹„ìš©ì„ ì €ì¥í•©ë‹ˆë‹¤: Key "x,y", Value: cost
            const costs = new Map();
            costs.set(`${start.x},${start.y}`, 0);

            const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];

            while (priorityQueue.length > 0) {
                // ë¹„ìš©ìˆœìœ¼ë¡œ ì •ë ¬í•˜ì—¬ ê°€ì¥ ìš°ì„ ìˆœìœ„ê°€ ë†’ì€(ë¹„ìš©ì´ ë‚®ì€) í•­ëª©ì„ ê°€ì ¸ì˜µë‹ˆë‹¤.
                priorityQueue.sort((a, b) => a.cost - b.cost);
                const { x, y, cost, path } = priorityQueue.shift(); // Get lowest cost node

                // ëª©ì ì§€ ë„ì°©
                if (x === end.x && y === end.y) {
                    return path; 
                }

                // ì´ë¯¸ ë” ì €ë ´í•œ ê²½ë¡œë¡œ ì´ ë…¸ë“œë¥¼ ë°©ë¬¸í–ˆë‹¤ë©´ ê±´ë„ˆëœë‹ˆë‹¤.
                if (cost > (costs.get(`${x},${y}`) || Infinity)) {
                    continue;
                }

                // ì´ì›ƒ ë…¸ë“œ í™•ì¸
                for (const [dx, dy] of directions) {
                    const newX = x + dx, newY = y + dy;

                    // ê²½ê³„ í™•ì¸
                    if (newX < 0 || newX >= size || newY < 0 || newY >= size) continue; 

                    const key = `${newX},${newY}`;
                    const tile = Array.isArray(mapData[0]) ? mapData[newY][newX] : mapData[newY].charAt(newX); 
                    
                    // ì¥ì• ë¬¼ í™•ì¸
                    if (obstacles.includes(tile)) continue;

                    // --- í•µì‹¬ ë¡œì§ ---
                    // ì´ë™ ë¹„ìš©ì„ í• ë‹¹í•©ë‹ˆë‹¤.
                    // ì—°ë£Œ ì…€ì€ ì´ë™ ë¹„ìš©ì´ í›¨ì”¬ ì €ë ´í•©ë‹ˆë‹¤.
                    let moveCost;
                    if (tile === ENTITY_TYPE.FUEL) {
                        // ì—°ë£Œ ìš°ì„ : ì¼ë°˜ ì´ë™ ë¹„ìš©ì˜ 1/10ë¡œ ì„¤ì •í•©ë‹ˆë‹¤.
                        // ì¦‰, ì•Œê³ ë¦¬ì¦˜ì€ 1ê°œì˜ ì—°ë£Œ í•­ëª©ì„ ì–»ê¸° ìœ„í•´
                        // ìµœëŒ€ 9ì¹¸ê¹Œì§€ "ëŒì•„ê°ˆ" ì˜í–¥ì´ ìƒê¹ë‹ˆë‹¤.
                        moveCost = 0.1; 
                    } else {
                        moveCost = 1; // ì¼ë°˜ ì´ë™ ë¹„ìš©
                    }
                    // --- í•µì‹¬ ë¡œì§ ë ---
                    
                    const newCost = cost + moveCost;

                    // ì´ ìƒˆë¡œìš´ ê²½ë¡œê°€ í•´ë‹¹ ì…€ì˜ ì´ì „ ê²½ë¡œë³´ë‹¤ ì €ë ´í•˜ë‹¤ë©´...
                    if (newCost < (costs.get(key) || Infinity)) {
                        costs.set(key, newCost); // ìƒˆë¡œìš´ ìµœì € ë¹„ìš© ê¸°ë¡
                        const newPath = [...path, {x: newX, y: newY}];
                        priorityQueue.push({ x: newX, y: newY, cost: newCost, path: newPath });
                    }
                }
            }
            
            return null; // No path found
        }
        // --- END OF NEW FUNCTION ---
        
        // --- THIS FUNCTION IS MODIFIED (from previous step) ---
        function calculatePath() {
            if (!passengerPos) { 
                currentPath = [];
                return;
            }
            const obstacles = [ENTITY_TYPE.BUILDING, ENTITY_TYPE.PEDESTRIAN];
            
            // --- MODIFICATION ---
            // ê¸°ì¡´: const path = findPathBFS(taxiPos, passengerPos, GRID_SIZE, board, obstacles);
            // ë³€ê²½:
            const path = findFuelPathDijkstra(taxiPos, passengerPos, GRID_SIZE, board, obstacles);
            // --- END MODIFICATION ---
            
            currentPath = path || [];
        }
        // --- 
        // --- 
        // --- END OF MODIFICATIONS ---
        // --- 
        // --- 


        // --- Game Initialization ---
        async function initializeAppSequence() {
             setupEventListeners(); 
             
             // íŠœí† ë¦¬ì–¼ ëª¨ë‹¬ì˜ ë³„ì  ê¸°ì¤€ë„ ìˆ˜ì •í•©ë‹ˆë‹¤.
             document.getElementById('grade-details-tutorial').innerHTML = `
                <strong>â­ ë³„ì  ê¸°ì¤€ (ì—°ìŠµ ëª¨ë“œ ì œì™¸)</strong><br>
                â˜…â˜†â˜†â˜†â˜†: ìŠ¹ê° 1ëª… ì´ìƒ<br>
                â˜…â˜…â˜†â˜†â˜†: ìŠ¹ê° 3ëª… ì´ìƒ<br>
                â˜…â˜…â˜…â˜†â˜†: ìŠ¹ê° 6ëª… ì´ìƒ<br>
                â˜…â˜…â˜…â˜…â˜†: ìŠ¹ê° 10ëª… ì´ìƒ & ìŠ¹ê°ë‹¹ ì´ë™ 12íšŒ ë¯¸ë§Œ<br>
                â˜…â˜…â˜…â˜…â˜…: (í•˜ë“œ ëª¨ë“œ) ìŠ¹ê° 15ëª… ì´ìƒ & ìŠ¹ê°ë‹¹ ì´ë™ 8íšŒ ë¯¸ë§Œ
             `;
             
             // íŠœí† ë¦¬ì–¼ ëª¨ë‹¬ì˜ ë³´í–‰ì ì„¤ëª…ë„ ìˆ˜ì •í•©ë‹ˆë‹¤.
             document.querySelector('#tutorial-modal ul li:nth-child(5)').innerHTML = `<span>ğŸ‘¤</span><strong>ë³´í–‰ì</strong>: ì¶©ëŒ ì‹œ ì—°ë£Œ -1 (ë…¸ë§/í•˜ë“œ)`;

             // Simplified startup: Just show the lobby
             showLobby();
             disableLobbyButtons(false); // Enable buttons immediately
             
             // Try to init audio context gently
             initAudio();
        }

        initializeAppSequence(); 

    </script>
</body>
</html>
